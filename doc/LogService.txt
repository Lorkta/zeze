log4j日志文件简单查询系统

大系统建议直接使用Flume，log4j可直接接入。
如果是一个小系统或者一个游戏分组，搭建Flume不是很合适。
当需要查询日志的时候，总是让运营拷贝文件回来的方式也比较麻烦。
所以考虑在zeze内建一个简单日志查询系统。
# 主要查询接口
按行搜索（考虑支持已知的多行日志，如stacktrace）
log?timeBegin=&timeEnd=&contains=
contans=包含的文本
log?timeBegin=&timeEnd=&&regex=
regex=正则表达式
# 系统架构
LogService 有一个独立的Zeze.Netty服务器，或者普通的Web服务器。两者的区别和影响是和Zeze通讯时用Zeze.Rpc还是http？
Gs 每台Gs就是一个日志节点，内建查询功能，由LogService调用。
LogService需要接入ServiceManager，能主动发现所有的Gs。
Gs 日志查询独立进程，不侵入Gs或者侵入RollingAppenderWithIndex都支持。
# 主要算法
为log4j的日志建立索引(time, offset)，关键，怎么动态的监视日志文件并建立索引。时间索引用rocksdb。
log4j 采用按size roll的RollingAppender，roll出来的文件自动zip压缩？可选能力。
两个文本搜索的实现。
已知多行日志的分析。

# 这个东西的价值如何？

【废弃】下面的不用看了。
一致性hash选择多实例远程日志服务

class LogService   // 日志服务，多实例，具有一定分布能力。底层可以自己简单实现，或者直接log4j。
class LogRequest // 日志Rpc协议类。
class LogAgent {  // 日志客户端
	// 采用一致性哈希管理多个日志服务，注意实际上这里的Connector对应一个LogService实例。
	// 一致性hash，当LogService变动时，appId对应的服务器的日志落地点有可能发生，这里不处理这个变化。
	private final ConsistentHash<Connector> logServices = new ConsistentHash<>();

	// 核心Agent实现，其他便利方法都调用这个。`
	// TODO logLevel，LogAgent需要从服务器同步过来，本地就可以判断。
	// TODO 远程日志服务不可用，先落地到本地文件，等恢复的时候，搬移过去，这个本地逻辑做成总是存在还是仅在失败时存在需要考虑一下。
	void log(String logName, String appId, String message, boolean waitForResult, @Nullable ProtocolHandle<LogRequest> asyncCallback) {
		var hash = hash(appId); // LogService实例稳定的时候，同一个appId的日志会落地到同一个LogService。
		var connector = logServices.get(hash);
		var r = new LogRequest();
		r.Argument.setLogName(logName);
		r.Argument.setAppId(appId);
		r.Argument.setMessage(message);

		if (waitForResult) {
			r.SendForWait(Connector.GetReadySocket()).await(); // 此时忽略callback。
			if (r.getResultCode() != 0)
				throw new RuntimeException("send log request error. code=" + IModule.getErrorCode(r.getResultCode()));
		} else if (null != asyncCallback)
			r.Send(Connector.GetReadySocket(), asyncCallback); // 异步检测结果。
		else
			r.Send(Connector.GetReadySocket()); // async, skip result and error.
	}
}

