Task & Achievement & Statistics
	任务成就以及相关统计

Task
	1. 目标
	【通用】任务系统。通用要求相当的抽象和灵活性。
	基本目标：实现基本的灵活的核心。
	扩展目标：实现一些比较常见的任务条件。
	用户扩展：用户可以自定义任务条件进行扩展。
// 这里用户是指玩家还是策划，玩家的话感觉没必要融到任务系统中，增加复杂度估计用的时候还不够用，另开发悬赏模块啥的就OK
// XXX 这里的用户是使用这个通用任务模块的程序员。

	2. 需求
	玩家当前任务管理，包括客户端当前任务列表通告。
	任务有向图（不允许出现环？）。
	任务交接（Npc）相关状态和提示。

	3 核心设计

	3.1 当前已接任务
	Task 任务，包含多个阶段
	Phase 阶段，包含多个条件
	Condition 条件，核心抽象
	ConditionEvent 条件事件，由玩家操作触发。发送给Task进行派发处理，最终Condition接受自己匹配的事件并更新自己的状态。
// phase没太明白作用，这个phase完成后，需要找npc交接一下么，还是自动跳到下个phase？之前任务开发，对话部分结构也挺复杂的，目前设计里没看到
// XXX phase是任务阶段，自动跳到下一个阶段的。这些目的吧：条件很多时，分割用；控制条件完成顺序。
// XXX 任务内对话还没有考虑，这里复杂的我觉得主要是配置。要不要做这个需要考虑一下。因为从任务定义来说，目标和奖励是核心，情节即使有分支，
// XXX 也是通过任务之间后续分支进行选择的。在任务内进行各种对话多数时候都没什么实质用途。
// XXX 【任务内对话需要考虑】

	3.2 任务配置
	任务配置由有向图描述。
	存在多个根。
	任务前置类型：All 所有的前置任务必须完成；AnyN 前置任务中可选的完成N个。
		用一个参数（PreposeRequired）描述，0表示all，[1, n]表示AnyN
		当PreposeRequired为n时，含义和0一样，都表示all了。
		但是为0时，如果前置任务数量发生了变化，仍然表示all。
		PreposeRequired>n一般是配置错误。这个错误合适的处理方式是允许这样的配置。
		因为前置任务数量变少时，可能PreposeRequired没有修改，应该尽可能运行下去。


	3.3 任务奖励
	在一般任务系统中，任务奖励除了奖励物品金钱经验，还可以奖励buf，一个特效等等。
	最终任务系统关联非常多其他的系统，不符合我们设计目标。所以，在这个任务方案中，
	奖励仅仅用一个奖励编号描述，所有的奖励细节由奖励系统实现。这里设想一下奖励系统的功能，
	a) 奖励金钱经验物品。
	b) 奖励一个物品列表中的随机物品。
	c) 玩家获得一个buf。
	d) 根据玩家职业，从他的职业装备列表中随机选择一个装备。
	奖励系统的实现是每个奖励配置异构，可以抽象出一个具有reward(long roleId, int id)接口。
	由奖励系统去关联其他的各种系统，解耦任务等其他任意需要奖励的地方。
	比如杀怪掉落表也可以纳入奖励系统。
	【结论：任务系统不做奖励啦。】
// 奖励系统预计要给任务面板奖励的说明提供足够好用的接口
//假如玩家系列任务中需要属于他自己的任务npc（交接任务的npc，可能地图上生成但不广播给其他玩家；跟随的npc，需要广播给其他玩家），是通过奖励系统生成么，他销毁通过什么控制
// XXX 奖励系统除了需要用户明确选择这种的接口难点，一般的都是一个列表，还算不难抽象。
// XXX 【好问题】任务进行过程中产生的动态内容是个好问题。通用任务系统需要参与这个。需要看看怎么设计。

	3.4 任务可接提示（Npc头顶叹号）
	需要数据：
	a) 玩家已完成任务历史记录，TaskCompleted。
	b）任务配置(3.2)，TaskGraphics。
	c) npc可接任务索引，NpcAcceptTask。任务配置中定义了接任务npc和交任务npc等信息，需要为npc建立索引。

// 是否需要支持低等级任务不显示叹号的功能，玩家对话可以接，但大地图上不提示
// 还有是否需要支持可接任务列表或者推荐任务列表这个界面，这种周围没有可见npc，没办法通过输入npc来检查，这种是策划另外编辑，还是任务系统自己来实现
// XXX 低等级不显示叹号，等等显示控制逻辑目前考虑不提供完整接口，就像下面的接口一样，只是返回任务和状态，外面根据细节（比如等级）自行决定更多的显示控制。
// XXX 【暂定】可接任务列表或者推荐任务列表，进一步开发的程序员可以通过特殊npcid使用下面的接口，然后在接任务时，不检测这种npcid和玩家的距离。

	算法描述：
	List<TaskWithAcceptState> CheckNpcExclamationMark(role, npc)
	{
		var result;
		foreach (var task : npc.NpcAcceptTask)
		{
			if (CheckPreposeTask(task, role.TaskCompleted)
				&& CheckTaskAcceptCondition(task, role) // 需要抽象？？？
				)
			{
				result.Add(task, eAcceptable); // 这个任务可接（黄色叹号）。
			}
			else
			{
				result.Add(task, eHasTask); // 有任务，但还不能接（灰色叹号）。
				// ？？？正常情况灰色叹号是不显示的，只有特殊（比如剧情任务）情况下，需要显示。
				// 这个怎么提供自定义选项？？？目前考虑是给出结果，由外面决定是否显示灰色叹号。
			}
		}
	}

	bool CheckPreposeTask(task, completed)
	{
		var n = task.PreposeRequired;
		if (n <= 0 || n > task.PreposeTask.size())
			n = task.PreposeTask.size();

		foreach (var prepose : task.PreposeTask)
		{
			if (completed.contains(prepose))
			{
				--n;
				if (n == 0)
					return true;
			}
		}
		return false;
	}

	【注意】上面算法中的task变量指的的是任务配置中的任务。

	3.5 任务可交提示（Npc头顶黄色问号）
	需要数据：
	玩家已接任务列表。
	List<Task> CheckNpcQuestionMark(role, npc)
	{
		var result;
		foreach (var task : role.TaskList)
		{
			var config = TaskGraphics.GetTask(task.Id);
			if (config.FinishNpc == npc && task.IsDone())
			{
				result.Add(task);
			}
		}
		return result;
	}

	3.6 任务接受触发
	a) npc 对话接受（3.4）
	b) 到达地图某个位置自动接受（魔兽世界任务？）
	   核心是任务需要配置到地图中。由地图服务器触发接受任务。
	   这种任务接受了，在持续期间一直存在，但是玩家离开任务范围可能不显示。
	c) 其他事件触发。
	   配置到任意其他地方。
	【总结】任务接受对于任务系统来说就是添加任务到玩家已接任务列表。
	当提供了接受任务的接口后，任何地方都可以调用。

// d) 上个任务完成的时候，直接接到新的任务在身上
// 玩家已接任务是否有上限，到达上限后，事件触发的任务能否接到玩家身上
// XXX 【d)】可以作为功能实现进去，如果接新任务npc配的很远也行，此时需要忽略npc和玩家的距离判断。
// XXX 【这个需要考虑】任务上限应该进限制玩家主动接的任务，系统自动触发的原则不做限制。实际上这种需要通过整个系统本身的设计来控制，
// XXX 比如剧情触发的任务是有限的，世界位置触发的任务需要有一个小的独立限制，顶掉最老的或者策略。

	3.7 其他任务功能（需要权衡是否做入这个抽象的核心的实现）
	a) 自动完成
	b) 任务有持续时间

	3.8 TaskCompleted 存储草稿
	这个是角色数据，每个角色记录一份。
	可以使用LinkedMap存储，即不限容量，也符合按任务编号快速查询的能力。
	【警告】需要考虑这个数据的其他快速访问需求，可能需要建立自己的数据结构。

	3.9 TaskGraphics 存储草稿
	这个是配置数据，定义好核心系统需要的数据结构和用户可自定义数据结构以后。
	提供构造数据的接口，由使用者从自己的任务配置数据中构造出这个系统需要的数据。
	草稿：
	class TaskGraphics
	{
		Map<TaskId, Task> TaskNodes; // 保存所有的任务配置。
		Set<TaskId> Root;
	}

	class Task
	{
		Set<TaskId> PreposeTasks;
		Set<TaskId> FollowTasks;
		int AcceptNpc; // 接受Npc
		int FinishNpc; // 交接Npc
		...
		dynamic CustomData; // 用户自定义扩展数据。
		【整理核心数据是重中之重】
	}

// 没看到玩家已接任务存盘数据结构
// 没看到任务接受条件怎么检查的
// isBreakIfAccepted没明白什么意思，为啥是ConditionEvent来决定的而不是Condition或者Phase
// XXX 已接任务存盘结构就是下面的class Task等。
// XXX 任务检查条件，检测通用目标已经定义好的条件，其他的通过自定义接口由进一步开发人员实现。存储上，TaskConfig用zeze.dynamic实现任意自定义数据的能力。
// XXX isBreakIfAccepted，控制这个事件多个接收者，还是只有一个（接受就停止广播）。比如两个已接任务都要杀相同的怪，当怪物被杀死时，isBreakIfAccepted为false，
// XXX 那么杀一个怪，两个任务计数同时增加，isBreakIfAccepted为true，那么第一个任务计数满了，下一个任务才开始计数。

	4. 任务实现草稿
	Condition.Name使用string。
	class Role {
		List<Task> tasks; // 已接（即当前）任务列表。
	}

	class Task {
		List<Phase> phases; // first is current phase.

		// 当条件发生了变化，调用这个更新任务状态。
		public boolean accept(ConditionEvent cevent) {
			var currentPhase = phases[0];
			var accecpted = currentPhase.accept(cevent);
			if (accecpted) {
				if (currentPhase.isDone()) {
					// 可能不删除阶段数据，用currentPhaseIndex来记录。看设计目标。暂定删除。
					phases.remove(0);
					if (phases.isEmpty()) // task is done.
						update task state;
				}
				// ...
				update view;					
			}
			return accecpted;
		}

		public void addPhase(Phase phase) {
			phases.add(phase);
		}
	}

	class Phase
	{
		List<Condition> conditions; // key is condition name

		public boolean accept(ConditionEvent cevent) {
			var accepted = false;
			for (var condition : conditions) {
				if (condition.getName().equals(cevent.getName())
					&& match.accept(cevent)) {
					if (match.isDone()) {
						conditions.remove(cevent.getName());
					}
					accepted = true;
					if (cevent.isBreakIfAccepted())
						break;
				}
			}
			return accepted;
		}

		public boolean isDone() {
			return conditions.isEmpty();
		}

		public void addCondition(Condition condition) {
			conditions.add(condition);
		}
	}

	// 核心抽象，需要把各种需求拿来过一遍，审核整体设计。
	abstract class Condition
	{
		// 条件名字。
		public abstract String getName();

		// 接受条件事件。
		// return true 事件接受，false 事件拒绝。
		public abstract boolean accept(ConditionEvent cevent);

		// 条件是否完成。
		public abstract boolean isDone();

		// 任务完成的时候调用，通常情况下，不需要额外实现。需要实现的例子参见后面的ConditionBag。
		public boolean finish() {
			return true;
		}
	}

	abstract class ConditionEvent {
		private boolean breakIfAccepted = false;

		public ConditionEvent(boolean breakIfAccepted) {
			this.breakIfAccepted = breakIfAccepted;
		}

		public ConditionEvent() {
			this(false);
		}

		// 事件名字。一般和相对应的Condition名字一样。
		public abstract String getName();

		public final boolean isBreakIfAccepted() {
			return breakIfAccepted;
		}
	}

	// 通用计数型条件，拥有一个计数值和期望值，给他不同的名字就能表示所有这种计数方式的条件。
	public class ConditionNamedCount extends Condition {
		private String name;
		private int count;
		private int expected;

		public ConditionNamedCount(String name, int expected) {
			this.name = name;
			this.expected = expected;
		}

		@Override
		public String getName() {
			return name;
		}

		@Override
		public boolean accept(ConditionEvent cevent) {
			if (cevent is Event e) {
				count += 1;
				return true;
			}
			return false;
		}

		@Override
		public abstract boolean isDone() {
			return killed >= expected;
		}

		public static class Event extends ConditionEvent {
			private String name;

			public Event(String name, boolean breakIfAccepted) {
				super(breakIfAccepted);
				this.name = name;
			}

			@Override
			public String getName() {
				return name;
			}
		}
	}

	// 杀怪计数型条件，可以配置可接受的怪物Id。怪物Id之间是或者的关系。如，杀死兔子或乌龟 0/10
	class ConditionKillMonster extends Condition {
		private int count;
		private int expected;
		private List<Integer> monsters; // 本来是期望的怪物Id集合，但为了描述顺序使用List，一般是少量的，所以问题不大。

		public ConditionKillMonster(int expected, List<Integer> monsters) {
			this.expected = expected;
			this.monsters.addAll(monsters); // copy
		}

		@Override
		public boolean accept(ConditionEvent cevent) {
			if (cevent is Event e) {
				if (monsters.contains(e.monster)) {
					count += e.increaseNumber;
					return true;
				}
			}
			return false;
		}

		@Override
		public abstract boolean isDone() {
			return killed >= expected;
		}

		@Override
		public String getName() {
			// 这种条件是模板性质的，它实际被配置成什么条件由内部的参数决定。
			return ConditionMonsterKill.class.getName();
		}

		// 杀死怪物的时候触发事件。
		public static class Event extends ConditionEvent {
			private int monster;
			private int increaseNumber;

			public Event(int monster, int increaseNumber) {
				this.monster = monster;
				this.increaseNumber = increaseNumber;
			}

			@Override
			public String getName() {
				return ConditionMonsterKill.class.getName();
			}
		}
	}

	class ConditionCompositeOr extends Condition {
		public Map<String, Condition> composite;
	}

	class ConditionBag extends Condition {
		private int count;
		private int expected;
		private int item; // 不考虑接受多个物品。这也可实现，不过即使实现也不建议用。

		@Override
		public boolean accept(ConditionEvent cevent) {
			if (cevent is Event e) {
				if (item == e.item) {
					var countNow = bag.count(e.item);
					if (countNow != count) {
						count = countNow;
						return true;
					}
				}
			}
			return false;
		}

		@Override
		public abstract boolean isDone() {
			return count >= expected;
		}

		@Override
		public String getName() {
			return ConditionBag.class.getName();
		}

		@Override
		public boolean finish() {
			if (bag.remove(item, expected))
				return true;
			// 当发生完成任务的时候扣除物品失败，意味着物品变成了不够的，更新一下本地的计数。
			// 最外面完成任务的时候会检查finish结果，失败的时候，会重新更新任务的状态。
			count = bag.count(item);
			return false;
		}

		// 在包裹中添加或者删除物品的时候触发事件。
		public static class Event extends ConditionEvent {
			private int item;

			public Event(int item) {
				this.item = item;
			}

			@Override
			public String getName() {
				return ConditionBag.class.getName();
			}
		}
	}

	也许一开始的定义是对的，Condition.Name ConditionEvent.Name就是逻辑上需要命名的名字。
	写好一个模板（比如ConditionExpectedCount）后，通过命名得到这种计数条件，每个命名一个
	具体类型。这个必须是应用上能区分开的。当像ConditionMonsterKill这种模板的写法时，它的
	名字就是模板名字，具体是哪种Condition，通过那内部的数据描述出来，如，小兔子或小乌龟 0/10，
	其中小兔子或小乌龟是ConditionMonsterKill内部的acceptedMonsters构造出来的。总结：也就是说
	Condition的实现可以一个名字代表一种具体的条件，也可以实现成模板，通过内部参数构造出具体
	条件。完美了？

	// 例子
	public class ConditionFactory {
		// 这个例子用下面的条件（ConditionKillMonster）也可以实现。
		public Condition newKillMonster1(int expected, int monsterId) {
			return new ConditionNamedCount(ConditionNamedCount.class.getName() + ".Monster." + monsterId, expected, "打败" + Monster.getName(monsterId));
		}

		public Condition newKillMonsterOr(int expected, int monsterId ...) {
			return new ConditionKillMonster(expected, List.of(monsterId), String.format("打败%s或%s", monsterId, monsterId)); // 外面格式化？这个格式化乱写的。
		}
	}

	5. 开发
	a) 项同学可以自由的根据需求开发这个系统；
	b) 理解上面的草稿，提到的问题我们可以讨论；
	c) 了解更多任务系统需求并进行抽象。

	6. @徐赣
	上面这个有一个完整实现过任务系统的人审核是最好的。
	就你啦。
