# Zeze-分布式事务和Raft无关

## 基本原理
本文解释分布式事务的实现方式。核心思想是使用“一致性缓存”解决多台服务器之间缓存同步问题，
加上原来单机事务机制，就实现了分布式事务。

## 本机事务
每个记录在本机进程中都拥有一把读写锁，控制并发读写的进行，实现多线程并发访问。这里，
为了更简单的理解其中并发原理，可以把这把锁看成普通的互斥锁，互斥原理上是一样的。
Zeze的锁粒度以记录为单位。为了避免死锁，Zeze提供了乐观锁算法。事务执行过程中
不加锁，所有修改仅当前事务可见。提交的时候对所有访问的记录排序并且加锁并进行冲突
检查。

## 本机乐观锁并发原理
事务内所有访问（读写）的记录在冲突检查时需要确保Timestamp没有变化。这样，事务成功时，
相当于独占所访问的记录的权利。这个并发策略是严格，但显然是正确的。
乐观锁算法要点
1. 排序加锁。
2. 加锁后检查冲突，即数据是否改变。冲突则重做事务。
3. 冲突重做时保持已经得到的锁，这样在冲突非常严重时，第二次执行事务一般都能成功，而
不会陷入一直冲突，事务永远没法完成的情况。
4. 重做保持锁，但重做过程中所访问的记录可能发生变化，所以重做仍然需要再次执行
lockAndCheck逻辑，并且处理所访问的记录发生变更的问题。
5. 逻辑处理返回错误码或者异常时也需要检查lockAndCheck，因为乐观锁在实际处理逻辑时
没有加锁，可能存在并发原因导致本来不应该发生逻辑错误，此时的仍然需要加锁并完成冲
突检查，如果冲突了，也需要重做。
6. 完整的实现参见 Zeze.Transaction.Transaction. lockAndCheck._

## 一致性缓存（分布式事务）
多台服务器共享后台数据库。每台服务器拥有自己的缓存。一致性缓存就是维护多台服务器
之间缓存的一致性。zeze一致性缓存和CPU-Cache-Memory的结构很像。所以参考了CPU
的MESI协议自己实现了一个锁分配机制。这个一致性缓存思路是非常暴力的，核心出发点
就是Global是全能的，知道所有东西。所以算法也非常直接简单。使用了类似MESI的状态
名，记录分成读写不可用三种状态。不可用表示记录在本地还没有反本文权限，读状态允许
同时存在于多台服务器缓存中，写状态只允许在一台服务器中。在一致性缓存之上，每一台
服务器的事务就能像自己独占所有数据一样，完成本地事务即可。这就是基于一致性缓存的
分布式事务。

## 一致性缓存的分布式锁管理流程
参考了CPU缓存同步算法（MESI），使用了其中3个状态：Modify,Share,Invalid。当主逻辑
服务器需要访问或修改数据时，向全局锁管理服务器（下面用Global称呼）申请Modify或
Share锁。Global知道所有记录的锁的分布状态。它根据申请的锁，向现拥有者发送相应的
降级请求；拥有者释放锁，并把数据刷新到后端服务器后，才给Global返回结果；Global
登记申请者的锁状态，给申请者返回结果。

## 分布式死锁检测
分布式不会死锁的基础保证是单机事务的乐观锁，所有的机器都排序访问分布式锁，整体上
“任何”时候都不会造成乱序，导致死锁。基本上分布式锁服务器（GlobalCacheManager，简称Global）
简单的按单个记录的方式理解并调度分布式读写锁的执行。但是这里仍然存在一个死锁。比如，
服务器A，B都得到了记录R的读锁，然后在自己本地乐观锁顺序中又同时去获取R的写锁，
此时，多机器之间的死锁就发生了。由于Global是远程访问，有超时，不会完全死掉，但会造成
不必要的错误发生。当然，Zeze解决了这个问题，它提前检测这种情况，并让后到的请求失败。
后到的请求收到失败错误码后，会释放本地拥有的所有锁，重做事务再次去争抢分布式锁的权限。
由于后到的请求释放了本地所有的锁，先前的请求就能得到正确处理。后到的请求事务重做后，
是全新的一次执行，再次进入新的争抢。

### 分布式锁是抢占式的
除非碰到上面所述的死锁检测，总是会成功。

### 分布式锁不会死锁
由于本地乐观锁排序了，全局也就不会死锁。

### 分布式锁新鲜保活机制
由于抢占式，可能多个服务器之间互相抢来抢去，最终没有任何服务器有机会完成事务。
新鲜保活机制保证抢到锁的服务器至少有一次执行机会，并且进行超时保活。

## 分布式单点和性能扩展
基于以上分析，分布锁管理是孤立的管理每个锁分配请求（上面的死锁检测是个例外），这样当
Global性能不足时，可以运行多个副本，把每个锁请求哈希到不同的副本上，即可实现性能扩展。
Global没有动态性能扩展能力，修改副本实例，需要全世界停服，修改配置重启。虽然多副本解决了
性能问题，但是概念上Global仍然是个“单点”，只要一个副本不能工作，哈希分配到这个副本的所有
记录的分布式访问都会失败。所以引入Raft，为每个Global副本提供备份，增加不间断运行的能力。
这里不详细介绍Raft，简单点一下题：即Raft和分布式事务的实现基本上没有关系，只是为了提供
副本备份。

## Global-Raft性能影响
Global-Raft由于Raft的复杂性，需要至少3倍的机器，而且每个请求都会额外增加一次玩过来回的延迟。
Global-Raft的性能要降低不少。非Raft版本的Global，单副本能够提供30w/s的并发请求。Raft版本没有
大规模压测过，可能只有非Raft的版本的1/5的性能。Global是否支持Raft的区分不是通过选项来实现，
而是完全不同的实现。Global具有以下几个版本。
1. Global-Async。不支持raft，异步实现，单副本高吞吐，机器占用少。没有很强的不间断运行需求
推荐使用这个版本。
2. Global-Sync。不支持Raft，多线程同步实现，无法提供高吞吐，是个实验版本，也是virtual的基础。
不推荐使用。
3. Global-Virtual。基于java虚拟线程同步实现的版本，各方面接近Async版本，可以使用。但由于Async
版本更简单稳定，而虚拟线程还是个新东西，推荐指数排在Async版后面。
4. Global-Raft。提供Raft支持，为了实现高吞吐量，需要java虚拟线程支持。在需要高可用性的情况下使用。

