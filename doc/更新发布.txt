
Hot热更在serverdev应用
0. 跟客户端无关，但主管们也要看看。
1. 虚拟世界正式发布（大规模导量）的计划时间点是什么时候？看看还有多少时间。
2. 看看 zeze/doc/zeze.docx 之"发布和热更"部分。已经拷贝，附到下面了。
3. Hot 现在 0.9 版本。加上一周左右测试。根据测试项目，可能需要几个人一起进行。然后就可以试用了。
4. Hot 1.0 版本。Redirect 方法的返回结果能使用Bean等自定义结构。
5. Hot 2.0 版本。Bean能作为接口方法的参数和结果。【这个是远期计划，遥遥无期了】
6. serverdev 挑选几个”无状态“的模块试试，或者等新的”无状态“模块。

zeze/doc/zeze.docx "发布和热更"

这一章说明服务器新版发布和热更新的方案。这里的服务器主要指主逻辑服务器。
、完全重启
停止全部服务器，全部更新，全部重启。更新频率不会太高，重启够快，这个方案最简单，虽然之后会出现一定的登录高峰，
但一般都扛的住。但系统规模越来越大，更新频率可能也会越来越高，这会导致大量重启，此时就需要考虑其他方式了。
这个方案总是可用。在下面的方案无法使用的时候，总是可以选择它。
、一台一台更新服务器
服务器本身是多台的，可以一台一台更新并重启。重启服务器上的用户重新登录，只要把重新登录处理的对用户比较无感，
就能实现接近无缝的升级。整个重启的过程可能需要一定的时间，此时新旧版本同时存在，需要应用具有新旧同时存在的兼容性。
、基于Instrumentation的任意class热更
Java自带的Instrumentation提供了任意class热更新机制，可以在不重启服务器的基础上，把新的class转载进去，
并保留所有服务器状态，完全无感无缝。这种热更有一定限制，一般用于紧急BUG修复，临时禁用某些功能，
增加日志进行调试等。具体使用限制请查阅Instrumentation的文档。涉及更新多台服务器时，一般也是一台一台独立进行，
虽然可以并发执行，但在很短的时间内，也是存在新旧版本同时都在运行的时刻，也需要注意更新内容的新旧版本兼容性。
当然一般Instrumentation式热更新，新旧版本问题一般不大。
、基于ClassLoader的以模块为单位的热更新
服务器不需要重启，按模块为单位热更。一次更新可以包含多个模块。存在新旧版本服务器同时运行，需要具有这个兼容性，
这个也可以提供原子的更新所有服务器来解决。这个热更新方式对开发模式有要求，并不能随意使用。
当服务启用了模块热更新以后，除了模块，服务还是存在一部分类是不支持热更新的。模块热更新也不是所有模块，
可以配置选择哪些模块支持热更新。模块开发，新版必须兼容旧版，兼容性是一个基本需求。
、开发要求：接口化
模块提供的所有服务必须都是接口。模块实现的接口是主接口，如果存在其他接口，必须由主接口得到。
系统装载模块的时候，会登记这个接口，可以由其他模块查询并使用。接口中的方法可以使用所有的不是模块内定义的类型，
包括java基本类型，jdk容器，第三方库，zeze等。模块内定义的类如果需要公开也必须接口化。Bean也是模块内自定义的类型，
也是不能用于接口方法的参数的，这个有计划解决，但短期内不支持Bean作为接口参数了。
、开发要求：接口引用保存规则
原则上不保存任何模块的提供的服务的接口引用。模块主接口特殊处理，引用其他模块主接口时，可以按下面方式保存一个上下文，避免每次都需要查询。
IModuleSome getSomeService() {
if (this.moduleSome == null）
this.moduleSome = HotManager.get(“MySol.ModuleSome”, IModuleSome.class);
return moduleSome.getService();
}
、开发要求：新版接口兼容性
新版接口必须兼容旧版接口，旧版本接口一旦发布就不能再修改。例，IModuleSome2 extends IModuleSome。
旧版接口一旦发布就不能再修改。这点很重要，就在这里再重复一次了。
、无状态模块
模块除了使用zeze的table等服务，没有任何自定义数据，即状态。除了没有定义自己的变量，
还需要注意 java.ScheduleThreadPool.schedule调用也是程序状态。
Zeze的Table在模块更新的时候，状态会被自动刷新。其他服务有时候也是有状态的，
可能需要使用特别的版本。见后面Zeze服务限制。Zeze的服务在热更下都会提供解决方案，而除了Zeze服务，
程序没有自己状态，就满足了“无状态“这个条件。这种情况下的热更，开发除了上面几点，如兼容性等要求外，
不需要更多额外的支持，就可以轻松的支持模块热更了。
、有状态模块
模块具有状态，模块更新的时候就需要处理处理状态迁移和刷新问题。这里分为两种。
	模块状态是自己内部创建的变量。
热更的时候，系统调用HotService 的方法：Void upgrade(HotService old);通知模块进行数据迁移。由于old是接口，
所以需要支持迁移的模块还需要在接口中定义访问旧状态的方法，（TODO，这是个问题，需要想想）。
完全无缝迁移对于某些复杂模块，或者当修改比较大时，是比较困难的。这时应用上可以采取让玩家重新登录的方式，
避免热更新的时候去迁移状态。举个例子，游戏的地图服务器，可选的保存一些状态（所在地图位置方向），
然后把玩家踢下线，玩家重新登录时恢复这些状态。
	模块状态保存了来自其他模块得到的数据引用。
分析，这个问题比较复杂，定义一个refresh接口是远远不够的。涉及两个基本问题。
A)使用了哪些模块？怎么通知？
B)数据引用一般随着逻辑功能执行的过程保存下来的，这个刷新看来是不可能的任务。推荐的规则是禁止保存来自其他模块的数据。
这能确保没有这个问题，但对应用限制比较大。还有个办法是对Bean的发布和热更进行特殊处理，使得Bean可以在接口中使用，并且作为返回值时，也可以保存下来。
、Redirect接口方法的参数和结果规范
Redirect接口方法直接公开到接口中，参数结果部分在解决Bean作为参数之前，和普通方法一样也是不能使用Bean作为参数的。
但Redirect不能返回结构结果，对它的功能影响较大。在Bean能作为参数之前，提供一个临时的解决思路。
当Redirect结果是一个Bean时，把这个Bean.class发布到非热更部分，不进行热更。当Bean结构需要修改时，定义新的Bean，
并应用到新的Redirect方法接口中。旧的方法和Bean也保留。这种方式虽然有一点点麻烦，但能工作。
	RedirectAllFuture<MyRedirectResult> 在xml种定义一个特殊的Bean，如下：
<bean name="MyRedirectResult" RedirectResult="true"/>
	其他参数或者结果，如果使用了自定义结构，只能是Bean或Data或BeanKey。
这些自定义结构按它们原来方式定义即可。
、Zeze服务限制
启用了模块热更新支持以后，Zeze服务需要一定限制。
A)	只能由应用的非热更代码调用，Zeze会阻止违规调用。
	Zeze.Component.TimerAccount & Zeze.Component.TimerRole
scheduleOnline(… TimerHandle handle …) 
scheduleOnlineNamed(… TimerHandle handle …)
所有以”TimerHandle handle”形式提供回调的在线定时器都会进行限制。
	Zeze.Util.EventDispatcher，用于Zeze.Game.Online & Zeze.Arch.Online
add(mode, handle) 调用者必须来自非热更模块。
B)	热更新模块必须使用接口。
	Zeze.Component.TimerAccount & Zeze.Component.TimerRole
scheduleOnlineHot(… Class<? extends TimerHandle> handleClass …)
scheduleOnlineNamedHot(… Class<? extends TimerHandle> handleClass …)
	Zeze.Util.EventDispatcher，用于Zeze.Game.Online & Zeze.Arch.Online
addHot(mode, handleClass) 热更模块必须使用这个接口注册事件。
、模块热更新启用配置
project hot=true 需要启用模块热更新时，首先必须配置这个，默认时false。
module hot=true 每个需要热更新的模块都需要单独配置，默认是false。
、在接口中使用自定义Bean的方案（TODO）
打包模块的时候，Bean打包到”非热更”模块；
Bean的热更采用基于字节码热更（如，sprint-loaded）的方案；
然后Bean就可以在接口中使用了。
、直接暴露数据表（TODO）
在接口中使用自定义Bean实现前不能直接暴露数据表。
暴露的表不能把引用保存下来，只能临时使用。


---------------------- 下面的不用看了，草稿 ---------------------------

3. 基于ClassLoader局部模块热更。
我准备先按纯interface的方式，设想一下整个热更发布系统。
规则0：纯interface+不能把从别的module.classloader装载得到的对象引用保存下来。
规则1：module暴露自己内部的table出去不能使用最终类型，必须是Zeze.Transaction.Table。这个还需要实验一下。
规则2：module，bean，interface化，需要涉及interface多版本的解决方案。
规则3：module interface是唯一的注册到框架的服务接口。
规则4：module interface 的函数参数类型只能是本名字空间下的interface和其他。都必须是能由框架loader装载的。
这里本空间的interface需要特殊判断。参数是lamda是可以的，它也是interface的一种。
规则5：静态变量和静态方法也需要用interface包装。
影响开发的规则：
0. 接口参数限制，基本类型，bean会自动得到支持，自定义类型必须interface化。
1. 不能保存别的模块得到的引用。确实需要再看怎么解决。
2. 建议无状态。确实需要，最好状态仅限内部使用，是不公开的。upgradeFrom(ModuleSome oldInstance) ，状态倒入。 
4. “所有”线程任务都必须通过Task管理，用来和热更互斥，当然也有允许例外，即确定不需要保护时也可以自己管理线程。
5. 新版本的接口兼容旧版本。
*. 开发限制应该就这几条了。其他尽量框架自动解决。

第二阶段：模块是有状态的。
a) 模块内部自己的私有数据，void upgrade(HotService old); 这里访问old的私有数据目前考虑也只能通过接口得到。
也就是说有状态模块需要一个 IMyAnyState getState(); 方法，其中 IMyAnyState 可能需要包含版本信息。
b) 模块缓存了其他模块创建的数据，void refresh(HotService current); 这里需要访问current的服务接口刷新本地数据。
这个只是抽象，可能还需要解决一些问题。预感没这么简单。
c) start依赖意味着此时可能缓存了其他创建的数据，那么也通过refresh刷新。
*) 有状态的a,b两种应该都不需要递归，通知一级就行，依赖关系最好能自动，实在不行就配置。这点需要继续考虑。

0. 发布（或最新）jar需要指定给gen使用。
AppVersion更新；
自动打包工具；
自动检测需要更新的模块，可行？

【Bean热更，用现有的字节码热更库】
	spring-loaded,jrebel,dcevm
	当前版本的发布运行目录，需要提供一份供Gen使用。没有发布过，即开发期，这个目录为空。开发期间一般不使用模块热更。
	DistributeServer 用来识别不支持热更的bean需改，这种修改需要重启服务器更新。
	依赖Bean热更，全局同一个Bean的概念：Online.LocalData, timer.CustomBean 等dynamic的地方。

1. Hot 从 Module 生成 interface 的【工具】。
void hotModuleInterface(File javaSource) {
	if (hasDistribute()) {
		var hotInterfaces = 列出Module的HotService体系;
		var oldMethods = 列出所有hotInterfaces的所有接口。
		var curMethods = 列出Module当前的public方法，除了【注解】标记不公开的。
		var (add, remove) = diff(oldMethods, curMethods);
		if (!remove.isEmpty())
			throw new RuntimeException(); // 先禁止删除接口中的方法。
		if (add.isEmpty())
			return;
		GenNewVersionInterface(add);
		修改Module相关方法的@Override；
		修改Module的implements到最新的HotService接口。

		return; // done
	}
	var hotInterfaces = 列出Module的HotService体系;
	if (hotInterfaces.size() > 1)
		throw new RuntimeException(); // 开发期间，不维护多个interface。
	var hotInterface1 = hotInterfaces.size() == 1 ? hotinterfaces.get(0) : new hotInterface();
	var oldMethods = 列出所有hotInterfaces的所有接口。
	var curMethods = 列出Module当前的public方法，除了【注解】标记不公开的。
	var (add, remove) = diff(oldMethods, curMethods);
	add(add, hotInterface1);
	修改Module相关方法的@Override；
	remove(remove, hotInterface1);
	*** 不修改Module相关方法的@Override；remove方法需要自己【手动】确认删除。
	hotInterface1.save();
}

李成华:
Hot Redirect 返回结果参数是自定义结构时不能作为接口暴露，怎么处理比较好。
	Redirect的返回结果是自定义结构（Bean Or RedirectResult），把这个结构发布到interface.jar里面，【不支持热更】。
	新版本的Redirect强制使用新的自定义结构，也就是完全新的自定义结构（有点点手动多版本的意思）。
	问题：
	1. 这算是一个临时解决方案。
	2. 未来如果实现ibean热更，这个完全看作两个函数（两个自定义结构）的方式也是可以工作的。
	3. ibean热更以后，参数里面的bean具有自动多版本兼容了。
	4. 看起来未来不会造成兼容问题吧。

李成华:
按这个原则，其他方法的bean也可以这样处理，但是bean失去修改能力有点不可接受，所以这个方式只给redirect开个口。

李成华:
未来ibean之类的方案支持了以后，redirect不需要特殊处理，存在的多个"版本"bean的结果的方法都自动变成可以修改bean结构的，
发布上有一点点修改。另外如果是ibean方案，原型上RedirectFuture<IBeanResult>，可能要改成IBean，这个看未来方案了。
当然这个短期不会开发了。稍微预想一下。

李成华:
接口上的修改可能不一定发生，未来可能的方案，ibean.name 就是bean.name，实现才是 bean._name_，
创建通过Pod Or ModuleService.newBeanName()方式。随便畅想啊。bean.name直接是接口以后，
老的new方式编译会出错，所以可以安全的改到Pod Or ModuleService.newBeanName()方式。
还行。
