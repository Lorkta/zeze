【更新发布方案】

0. 停止全部服务器，全部更新，全部重启。
【这里可能还包括需要更新客户端】
更新频率不会太高，重启够快，这个方案最简单，虽然之后会出现一定的登录高峰，但一般都扛的住。
但系统规模越来越大，更新频率可能也会越来越高，这会导致大量重启，此时就需要考虑其他方式了。
【这个方案总是可用。在下面的方案无法使用的时候，总是可以选择它】

1. 一台一台更新服务器。
【问题】存在新旧版本服务器同时运行，需要具有这个兼容性。
方案实现草稿：
a) App 需要定义版本号。
b) 调用 Schemas.setAppPublishVersion
c) server 给linkd报告Info时带上版本号。
d) linkd 发现多个版本号，则只给最新的分发新登录。
e) 新旧版有同时运行的时刻，后端数据库访问的时候，旧版不能把新版新增的变量搞丢了。【已实现，下面碰到这个需求不再列出】
【分析】这是个接近完全重启，但又带来需要新旧版同时运行并兼容的问题的方案。
【分析】实际使用价值不大，主要是提出了这个问题。后面方案3会重新涉及这个问题。

2. 新旧版本同时运行，分成两个集合，两者之间几乎没有交互。旧集合逐步关闭。
a) ServiceManager 在动态管理服务器时，不能把两个集合混起来。
【通过应用提供的带上版本号的PrefixName自动形成不同的集合】【Zeze已支持，由应用进行配置】
b) 新旧集合之间可能需要通讯，Zeze需要提供一点支持。【TODO】
c) 这个方案难点在于应用的所有功能能不能得到合理安排。【XXX】
e) Linkd使用独立发现（DNS）,新旧版连接到不同的Linkd集合。
【每个版本都需要更新DNS？】
【DNS不属于Zeze功能，但Linkd发现，Zeze以后是否需要提供支持机制？（DNS已经够好了，自己提供价值不大）】
f) 在更新频率高的时候，如果只是新旧两个，也是扛不住的。可能需要扩展成同时运行更多版本。
【分析】这是个奇特的方案，它最主要的目的是降低兼容性的压力，但个人感觉这个方案不可预测。

3. 基于ClassLoader局部模块热更。
服务器不需要重启，按Module为单位热更。一次更新可以包含多个模块。不考虑多个Module打包成Bundle模式，避免引入新的概念。
【问题】存在新旧版本服务器同时运行，需要具有这个兼容性。这个问题同方案1，但有点区别。
因为是局部更新，服务器没有重启，所以有个解决思路：所有服务器为单位原子的热更。只要这个原子化锁定时间够短，是可行的。【TODO】
【问题】几个模块一起热更，存在更新顺序问题。【已解决，见后HotReadWriteLock】
【问题】模块功能兼容性必须成为开发者的一个基本需求。绕开这个问题的方案都过于理想了。当兼容代价太大，使用方案0(停止世界再重启)即可.

方案实现草稿：【下面几乎都是TODO，不单独标出来了】
a) 可选的定义App版本号，任何Module需要更新，都会同时更新App版本号。这样方案1的Linkd只给新版分发新登录会自动生效。
b) 每个Module一个ClassLoader，这是实现热更的技术基础。
c) 热更最根本的操作是生成Module的新实例，并发布，即更新相关地方的引用。如：App里的全局引用，Zeze里面Table的引用，重新注册协议。
d) HotReadWriteLock 所有的线程执行的时候加读锁，热更的时候加写锁。进程内热更需要加锁的主要是发布引用，很快，其他步骤不需要的尽量锁外执行。
这个锁内多个Module一起热更，所以顺便解决了上面热更顺序问题。
e) App的Module构造|初始化|Start顺序定义继续保留，是否需要修订？列出这个，备注一下。
f) 所有服务器为单位进行原子的热更。上面第一个问题，避免新旧版本同时运行就可以实现了，能不能用就看实际疗效了。
g) AppVersion更新；自动打包工具；自动检测需要更新的模块，可行？
h) 原则：模块引用不能保存；模块直接保留Table的引用不能保存；模块暴露的所有引用？数据对象(如Bean)允许保存下来？

我准备先按纯interface的方式，设想一下整个热更发布系统。
规则0：纯interface+不能把从别的module.classloader装载得到的对象引用保存下来。
规则1：module暴露自己内部的table出去不能使用最终类型，必须是Zeze.Transaction.Table。这个还需要实验一下。
规则2：module，bean，interface化，需要涉及interface多版本的解决方案。
规则3：module interface是唯一的注册到框架的服务接口。
规则4：module interface 的函数参数类型只能是本名字空间下的interface和其他。都必须是能由框架loader装载的。
这里本空间的interface需要特殊判断。参数是lamda是可以的，它也是interface的一种。
规则5：静态变量和静态方法也需要用interface包装。
规则6：zeze不准备支持热更，暴露的服务如果有订阅注册，全部需要规划。先举个例子：timer使用className和callback跟外面交互，
其中className方式具有自动动态特性，刚好符合要求，但是callback需要处理（改造成className？）。等等。
这是基本版，当出现需要保存得到的interface引用时，看看能不能制定出合适的规则。
timer class.forName还是需要实验一下。这里是不是也涉及到了import class。
影响开发的规则：
0. 接口参数限制，基本类型，bean会自动得到支持，自定义类型必须interface化。
1. 不能保存别的模块得到的引用。确实需要再看怎么解决。
2. 建议无状态。确实需要，最好状态仅限内部使用，是不公开的。upgradeFrom(ModuleSome oldInstance) ，状态倒入。 
4. “所有”线程任务都必须通过Task管理，用来和热更互斥，当然也有允许例外，即确定不需要保护时也可以自己管理线程。
5. 新版本的接口兼容旧版本。
*. 开发限制应该就这几条了。其他尽量框架自动解决。
【规则重新总结】
module是唯一的第一公开服务，有其他公开接口，也通过module得到；
module默认所有的public方法，除了注解声明不公开外，都是接口的一部分；
发布的时候，接口自动生成，检测变化，生成不同版本；

热更发布开发计划(碰到问题，很有可能需要回头修改规则)
0. Bean 接口化。Bean接口必须兼容旧版的，多版本管理问题？
1. 模块 Table 暴露出去使用Zeze.Transaction.Table<Key, ValueBean>，由于Zeze稳定，这里预计不会碰到问题，需要实验。
2. Module接口规范，其中最基本要求是新版接口兼容旧版。多版本管理问题？
3. Module接口自动生成，需要工具进行自动解析并生成接口，并且检查是否符合规范，是否兼容性（需要保存就发布的接口，多版本管理问题）。
4. Zeze各种服务需要动态化或者能重新注册。
*) 协议重新注册。
*) Zeze内管理的Table实例覆盖（重新注册的一种，由于table有初始化需求，原来是启动静态处理的，需要能动态支持）。
Zeze已经提供了一个受限动态表，可能需要参考这个，重新设计这块的功能。
*) timerAccount timerRole 原来为了优化直接保存Handle，需要改成className，用class.forName动态化。还有没有其他方案？
*) Online模块：事件订阅和LocalData的升级。
*) Zeze的某些全局定制服务加限制，只能由应用全局设置（不会热更），不能在module里面设置。caller.classLoader!=Zeze.classLoader，能判断这个？
*) more more。

TODO
 监视目录变更还是需要 【差临门一脚】
module 生成 interface 工具（预计下周）

0. 原则
模块interface 化，所有被其他模块访问的功能和数据对象都是interface；
inteface新版兼容旧版。

第一阶段：模块是无状态的。
start 初始化启动时，solution里面可以描述启动顺序，解决依赖问题。
热更一个模块时，其他模块都是准备好的，它的依赖没问题；
依赖它的模块根据无状态和服务接口兼容特性，在运行中会得到新模块的新的interface，使用起来也没问题。
热更多个模块时，这个更新集合跟其他部分没问题，集合内部也存在start依赖，这个可以在提交热更集合时定义好顺序。
现在HotManager.install参数是List，可以描述顺序。
?  只定义这两个要求是否足够 1. 第一次启动顺序，2. 热更集合启动顺序

第二阶段：模块是有状态的。
a) 模块内部自己的私有数据，void upgrade(HotService old); 这里访问old的私有数据目前考虑也只能通过接口得到。
也就是说有状态模块需要一个 IMyAnyState getState(); 方法，其中 IMyAnyState 可能需要包含版本信息。
b) 模块缓存了其他模块创建的数据，void refresh(HotService current); 这里需要访问current的服务接口刷新本地数据。
这个只是抽象，可能还需要解决一些问题。预感没这么简单。
c) start依赖意味着此时可能缓存了其他创建的数据，那么也通过refresh刷新。
*) 有状态的a,b两种应该都不需要递归，通知一级就行，依赖关系最好能自动，实在不行就配置。这点需要继续考虑。

热更（增加）模块与模块启动依赖之间的定义有冲突。即一个模块热更对依赖它的模块的影响问题。
这样定义：start仅仅作用于启动，以后热更不需要考虑这个问题，热更仅提供服务接口的兼容。
是否可行？
当然，启动顺序还是有一定保证。
1. 服务第一次启动时，定义好的启动顺序还是保证。
2. 几个模块一起热更，它们之间启动顺序也可以保证。
3. 热更模块跟现有模块之间就不考虑启动顺序问题。
----
redirect 问题：
1. 预先生成出子类现在是全局包里面的，只用于zeze内部，不需要考虑cl；
2. app需要限制只能即时编译了，因为InMemoryJavaCompiler支持设置parent classloader，
所以，启用了热更，设置一下，可能就没有问题了。这个需要确认。 

技术笔记：
OSGi ClassLoader 将按照下面的顺序进行类搜索：
1）将以java.*开头的类委派给父类加载器加载。
2）否则，将委派列表名单内的类委派给父类加载器加载。
3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
7）否则，类查找失败。
【选择】OSGi 特性是很多的，大砍特砍，仅保留热更发布。
【选择】模块多版本同时存在需求考虑一下。目前判断是不可行。

4. Arch.Linkd.ChoiceProvider 机制上花招。


【异想天开】
0. 兼容是开发人员绕不开的问题，只能降低难度，但永远避免不了。特别是服务器开发人员。
1. 客户端也支持按模块热更就完美了。
2. 后端数据库需求，高效的设置不安全点，此后较长一段时间（如，一天）的数据修改可以全部快速回滚，
当然也可以设为安全，把修改提交，然后一切正常继续。用于版本更新时，减少重大bug引起的大问题。
对于游戏，回滚期间产生的高价值掉落，通过log给玩家补上。
