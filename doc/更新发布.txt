3. 基于ClassLoader局部模块热更。
我准备先按纯interface的方式，设想一下整个热更发布系统。
规则0：纯interface+不能把从别的module.classloader装载得到的对象引用保存下来。
规则1：module暴露自己内部的table出去不能使用最终类型，必须是Zeze.Transaction.Table。这个还需要实验一下。
规则2：module，bean，interface化，需要涉及interface多版本的解决方案。
规则3：module interface是唯一的注册到框架的服务接口。
规则4：module interface 的函数参数类型只能是本名字空间下的interface和其他。都必须是能由框架loader装载的。
这里本空间的interface需要特殊判断。参数是lamda是可以的，它也是interface的一种。
规则5：静态变量和静态方法也需要用interface包装。
影响开发的规则：
0. 接口参数限制，基本类型，bean会自动得到支持，自定义类型必须interface化。
1. 不能保存别的模块得到的引用。确实需要再看怎么解决。
2. 建议无状态。确实需要，最好状态仅限内部使用，是不公开的。upgradeFrom(ModuleSome oldInstance) ，状态倒入。 
4. “所有”线程任务都必须通过Task管理，用来和热更互斥，当然也有允许例外，即确定不需要保护时也可以自己管理线程。
5. 新版本的接口兼容旧版本。
*. 开发限制应该就这几条了。其他尽量框架自动解决。

第二阶段：模块是有状态的。
a) 模块内部自己的私有数据，void upgrade(HotService old); 这里访问old的私有数据目前考虑也只能通过接口得到。
也就是说有状态模块需要一个 IMyAnyState getState(); 方法，其中 IMyAnyState 可能需要包含版本信息。
b) 模块缓存了其他模块创建的数据，void refresh(HotService current); 这里需要访问current的服务接口刷新本地数据。
这个只是抽象，可能还需要解决一些问题。预感没这么简单。
c) start依赖意味着此时可能缓存了其他创建的数据，那么也通过refresh刷新。
*) 有状态的a,b两种应该都不需要递归，通知一级就行，依赖关系最好能自动，实在不行就配置。这点需要继续考虑。

0. 发布（或最新）jar需要指定给gen使用。
AppVersion更新；
自动打包工具；
自动检测需要更新的模块，可行？

【Bean热更，用现有的字节码热更库】
	spring-loaded,jrebel,dcevm
	当前版本的发布运行目录，需要提供一份供Gen使用。没有发布过，即开发期，这个目录为空。开发期间一般不使用模块热更。
	DistributeServer 用来识别不支持热更的bean需改，这种修改需要重启服务器更新。
	依赖Bean热更，全局同一个Bean的概念：Online.LocalData, timer.CustomBean 等dynamic的地方。

1. Hot 从 Module 生成 interface 的【工具】。
void hotModuleInterface(File javaSource) {
	if (hasDistribute()) {
		var hotInterfaces = 列出Module的HotService体系;
		var oldMethods = 列出所有hotInterfaces的所有接口。
		var curMethods = 列出Module当前的public方法，除了【注解】标记不公开的。
		var (add, remove) = diff(oldMethods, curMethods);
		if (!remove.isEmpty())
			throw new RuntimeException(); // 先禁止删除接口中的方法。
		if (add.isEmpty())
			return;
		GenNewVersionInterface(add);
		修改Module相关方法的@Override；
		修改Module的implements到最新的HotService接口。

		return; // done
	}
	var hotInterfaces = 列出Module的HotService体系;
	if (hotInterfaces.size() > 1)
		throw new RuntimeException(); // 开发期间，不维护多个interface。
	var hotInterface1 = hotInterfaces.size() == 1 ? hotinterfaces.get(0) : new hotInterface();
	var oldMethods = 列出所有hotInterfaces的所有接口。
	var curMethods = 列出Module当前的public方法，除了【注解】标记不公开的。
	var (add, remove) = diff(oldMethods, curMethods);
	add(add, hotInterface1);
	修改Module相关方法的@Override；
	remove(remove, hotInterface1);
	*** 不修改Module相关方法的@Override；remove方法需要自己【手动】确认删除。
	hotInterface1.save();
}
