Hot 热更测试

11. Arch.Online.setLocalBean, 热更后读取访问。由于zezex目前用的Game.Online，没有这个测试环境，先列在这里。
12. TimeAccount.scheduleOnlineHot, scheduleOnlineNamedHot, 同11点，由于zezex，没有这个测试环境，先列在这里。

3. 基于ClassLoader局部模块热更。
我准备先按纯interface的方式，设想一下整个热更发布系统。
规则0：纯interface+不能把从别的module.classloader装载得到的对象引用保存下来。
规则1：module暴露自己内部的table出去不能使用最终类型，必须是Zeze.Transaction.Table。这个还需要实验一下。
规则2：module，bean，interface化，需要涉及interface多版本的解决方案。
规则3：module interface是唯一的注册到框架的服务接口。
规则4：module interface 的函数参数类型只能是本名字空间下的interface和其他。都必须是能由框架loader装载的。
这里本空间的interface需要特殊判断。参数是lamda是可以的，它也是interface的一种。
规则5：静态变量和静态方法也需要用interface包装。
影响开发的规则：
0. 接口参数限制，基本类型，bean会自动得到支持，自定义类型必须interface化。
1. 不能保存别的模块得到的引用。确实需要再看怎么解决。
2. 建议无状态。确实需要，最好状态仅限内部使用，是不公开的。upgradeFrom(ModuleSome oldInstance) ，状态倒入。 
4. “所有”线程任务都必须通过Task管理，用来和热更互斥，当然也有允许例外，即确定不需要保护时也可以自己管理线程。
5. 新版本的接口兼容旧版本。
*. 开发限制应该就这几条了。其他尽量框架自动解决。

第二阶段：模块是有状态的。
a) 模块内部自己的私有数据，void upgrade(HotService old); 这里访问old的私有数据目前考虑也只能通过接口得到。
也就是说有状态模块需要一个 IMyAnyState getState(); 方法，其中 IMyAnyState 可能需要包含版本信息。
b) 模块缓存了其他模块创建的数据，void refresh(HotService current); 这里需要访问current的服务接口刷新本地数据。
这个只是抽象，可能还需要解决一些问题。预感没这么简单。
c) start依赖意味着此时可能缓存了其他创建的数据，那么也通过refresh刷新。
*) 有状态的a,b两种应该都不需要递归，通知一级就行，依赖关系最好能自动，实在不行就配置。这点需要继续考虑。

0. 发布（或最新）jar需要指定给gen使用。
AppVersion更新；
自动打包工具；
自动检测需要更新的模块，可行？

【Bean热更，用现有的字节码热更库】
	spring-loaded,jrebel,dcevm
	当前版本的发布运行目录，需要提供一份供Gen使用。没有发布过，即开发期，这个目录为空。开发期间一般不使用模块热更。
	DistributeServer 用来识别不支持热更的bean需改，这种修改需要重启服务器更新。
	依赖Bean热更，全局同一个Bean的概念：Online.LocalData, timer.CustomBean 等dynamic的地方。

1. Hot 从 Module 生成 interface 的【工具】。
void hotModuleInterface(File javaSource) {
	if (hasDistribute()) {
		var hotInterfaces = 列出Module的HotService体系;
		var oldMethods = 列出所有hotInterfaces的所有接口。
		var curMethods = 列出Module当前的public方法，除了【注解】标记不公开的。
		var (add, remove) = diff(oldMethods, curMethods);
		if (!remove.isEmpty())
			throw new RuntimeException(); // 先禁止删除接口中的方法。
		if (add.isEmpty())
			return;
		GenNewVersionInterface(add);
		修改Module相关方法的@Override；
		修改Module的implements到最新的HotService接口。

		return; // done
	}
	var hotInterfaces = 列出Module的HotService体系;
	if (hotInterfaces.size() > 1)
		throw new RuntimeException(); // 开发期间，不维护多个interface。
	var hotInterface1 = hotInterfaces.size() == 1 ? hotinterfaces.get(0) : new hotInterface();
	var oldMethods = 列出所有hotInterfaces的所有接口。
	var curMethods = 列出Module当前的public方法，除了【注解】标记不公开的。
	var (add, remove) = diff(oldMethods, curMethods);
	add(add, hotInterface1);
	修改Module相关方法的@Override；
	remove(remove, hotInterface1);
	*** 不修改Module相关方法的@Override；remove方法需要自己【手动】确认删除。
	hotInterface1.save();
}

李成华:
Hot Redirect 返回结果参数是自定义结构时不能作为接口暴露，怎么处理比较好。
	Redirect的返回结果是自定义结构（Bean Or RedirectResult），把这个结构发布到interface.jar里面，【不支持热更】。
	新版本的Redirect强制使用新的自定义结构，也就是完全新的自定义结构（有点点手动多版本的意思）。
	问题：
	1. 这算是一个临时解决方案。
	2. 未来如果实现ibean热更，这个完全看作两个函数（两个自定义结构）的方式也是可以工作的。
	3. ibean热更以后，参数里面的bean具有自动多版本兼容了。
	4. 看起来未来不会造成兼容问题吧。

李成华:
按这个原则，其他方法的bean也可以这样处理，但是bean失去修改能力有点不可接受，所以这个方式只给redirect开个口。

李成华:
未来ibean之类的方案支持了以后，redirect不需要特殊处理，存在的多个"版本"bean的结果的方法都自动变成可以修改bean结构的，
发布上有一点点修改。另外如果是ibean方案，原型上RedirectFuture<IBeanResult>，可能要改成IBean，这个看未来方案了。
当然这个短期不会开发了。稍微预想一下。

李成华:
接口上的修改可能不一定发生，未来可能的方案，ibean.name 就是bean.name，实现才是 bean._name_，
创建通过Pod Or ModuleService.newBeanName()方式。随便畅想啊。bean.name直接是接口以后，
老的new方式编译会出错，所以可以安全的改到Pod Or ModuleService.newBeanName()方式。
还行。
