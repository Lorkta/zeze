【更新发布方案】

0. 停止全部服务器，全部更新，全部重启。
【这里可能还包括需要更新客户端】
更新频率不会太高，重启够快，这个方案最简单，虽然之后会出现一定的登录高峰，但一般都扛的住。
但系统规模越来越大，更新频率可能也会越来越高，这会导致大量重启，此时就需要考虑其他方式了。
【这个方案总是可用。在下面的方案无法使用的时候，总是可以选择它】

1. 一台一台更新服务器。
【问题】存在新旧版本服务器同时运行，需要具有这个兼容性。
方案实现草稿：
a) App 需要定义版本号。
b) 调用 Schemas.setAppPublishVersion
c) server 给linkd报告Info时带上版本号。
d) linkd 发现多个版本号，则只给最新的分发新登录。
e) 新旧版有同时运行的时刻，后端数据库访问的时候，旧版不能把新版新增的变量搞丢了。【已实现，下面碰到这个需求不再列出】
【分析】这是个接近完全重启，但又带来需要新旧版同时运行并兼容的问题的方案。
【分析】实际使用价值不大，主要是提出了这个问题。后面方案3会重新涉及这个问题。

2. 新旧版本同时运行，分成两个集合，两者之间几乎没有交互。旧集合逐步关闭。
a) ServiceManager 在动态管理服务器时，不能把两个集合混起来。
【通过应用提供的带上版本号的PrefixName自动形成不同的集合】【Zeze已支持，由应用进行配置】
b) 新旧集合之间可能需要通讯，Zeze需要提供一点支持。【TODO】
c) 这个方案难点在于应用的所有功能能不能得到合理安排。【XXX】
e) Linkd使用独立发现（DNS）,新旧版连接到不同的Linkd集合。
【每个版本都需要更新DNS？】
【DNS不属于Zeze功能，但Linkd发现，Zeze以后是否需要提供支持机制？（DNS已经够好了，自己提供价值不大）】
f) 在更新频率高的时候，如果只是新旧两个，也是扛不住的。可能需要扩展成同时运行更多版本。
【分析】这是个奇特的方案，它最主要的目的是降低兼容性的压力，但个人感觉这个方案不可预测。

3. 基于ClassLoader局部模块热更。
服务器不需要重启，按Module为单位热更。一次更新可以包含多个模块。不考虑多个Module打包成Bundle模式，避免引入新的概念。
【问题】存在新旧版本服务器同时运行，需要具有这个兼容性。这个问题同方案1，但有点区别。
因为是局部更新，服务器没有重启，所以有个解决思路：所有服务器为单位原子的热更。只要这个原子化锁定时间够短，是可行的。【TODO】
【问题】几个模块一起热更，存在更新顺序问题。【已解决，见后HotReadWriteLock】
【问题】模块功能兼容性必须成为开发者的一个基本需求。绕开这个问题的方案都过于理想了。当兼容代价太大，使用方案0即可.

方案实现草稿：【下面几乎都是TODO，不单独标出来了】
a) 可选的定义App版本号，任何Module需要更新，都会同时更新App版本号。这样方案1的Linkd只给新版分发新登录会自动生效。
b) 每个Module一个ClassLoader，这是实现热更的技术基础。
c) 热更最根本的操作是生成Module的新实例，并发布，即更新相关地方的引用。如：App里的全局引用，Zeze里面Table的引用，重新注册协议。
d) HotReadWriteLock 所有的线程执行的时候加读锁，热更的时候加写锁。进程内热更需要加锁的主要是发布引用，很快，其他步骤不需要的尽量锁外执行。
这个锁内多个Module一起热更，所以顺便解决了上面热更顺序问题。
e) App的Module构造|初始化|Start顺序定义继续保留，是否需要修订？列出这个，备注一下。
f) 所有服务器为单位原子的热更。上面第一个问题。可以实现，能不能用就看实际疗效了。

技术笔记：
OSGi ClassLoader 将按照下面的顺序进行类搜索：
1）将以java.*开头的类委派给父类加载器加载。
2）否则，将委派列表名单内的类委派给父类加载器加载。
3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
7）否则，类查找失败。
【选择】OSGi 特性是很多的，大砍特砍，仅保留热更。
【选择】模块多版本同时存在需求考虑一下。目前判断是不可行。

4. Arch.Linkd.ChoiceProvider 机制上花招。


【异想天开】
0. 兼容是开发人员绕不开的问题，只能降低难度，但永远避免不了。特别是服务器开发人员。
1. 客户端也支持按模块热更就完美了。
2. 后端数据库需求，高效的设置不安全点，此后较长一段时间（如，一天）的数据修改可以全部快速回滚，
当然也可以设为安全，把修改提交，然后一切正常继续。用于版本更新时，减少重大bug引起的大问题。
对于游戏，回滚期间产生的高价值掉落，通过log给玩家补上。
