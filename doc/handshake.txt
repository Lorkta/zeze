
现有Handshake协商协议。

client                                                                     server
  |<--------------------- SHandshake0(enableEncrypt) -------------------------| enableEncrypt 为服务器配置参数。
  |if (!enableEncrypt) -- CHandshakeDone ------------------------------------>| 【Done 1】未加密协商结束。
  |else ----------------- CHandshake(encrypt param) ------------------------->|
  |<------ SHandshake(encrypt param; S2cNeedCompress, C2sNeedCompress) -------| 
  |---------------------- CHandshakeDone ------------------------------------>| 【Done 2】加密协商结束，通知服务器控制双向的压缩支持。

新的Handshake协商协议
  支持多压缩算法。

client                                                                                        server
  |<----- SHandshake0(recommendedEncrypt,supportedEncryptList*, supportedCompressList*) ---------| 参数服务器配置。加密列表不为空，则必须选择支持一种；压缩列表由客户端选择。
  |if (!enableEncrypt && !compress) -- CHandshakeDone ------------------------------------------>| 【Done 1】未加密未压缩。
  |else --------------- CHandshake(encryptType, binary encryptParam;choicedCompress:s2c,c2s) --->|
  |<------ SHandshake(encryptType, binary encryptParam; S2cNeedCompress, C2sNeedCompress) -------|
  |---------------------- CHandshakeDone ------------------------------------------------------->| 【Done 2】加密压缩协商结束。

兼容升级计划

一、不再进行协议没有解析完的错误检查。
   see Zeze.Net.Protocol.Decode

二、Handshake兼容

1. SHandshake0
   bool enableEncrypt -> int recommendedEncrypt; 旧版客户端readbool兼容readint。0表示不加密，其他都看成加密。
   supportedEncryptList*, 新增var，旧版不解码。
   supportedCompressList*,新增var，旧版不解码。

   旧版客户端流程以及兼容说明。
   if (!enableEncrypt)
   	send CHandshakeDone; 服务器保持旧的语义。未压缩也未加密。
   else
   	send CHandshake(...);
	entryptType = old_dh_group; // 1，entryptType为1是兼容旧版的定义。【这个要求服务器最初的加密类型兼容期间总是必须支持。】
	encryptParam = old_dh_data;

   新版客户端流程以及兼容说明。
   var (s2c, c2s) = selectCompress();
   if (!recommendedEncrypt == 0 && s2c == 0 && c2s == 0)
   	send CHandshakeDone; 服务器保持旧的语义。未压缩也未加密。
   else {
        var encryptType = recommendedEncrypt;
	var encryptParam = generateEncryptParam(encryptType); // recommendedEncrypt == 0 不加密时生成空的param。
   	send CHandshake(encryptType, encryptParam, s2c, c2s); // 服务器根据参数完全支持。
   }

2. CHandshake 新版服务器兼容说明
   系列化兼容旧版客户端。
   decode(dh_group -> encryptType, dh_data -> encryptParam);
   try {
	decode s2c, c2s;
   } catch (DecodeException ignored) {
   }

   const int eEncryptTypeDisable = 0;
   const int eEncryptTypeDefault = 1;

   实现兼容
   switch (encryptType)
   {
   	case eEncryptTypeDisable:
		break;
	case eEncryptTypeDefault:
		process encrypt param and generate response;
		break;
   }
   send SHandshake(response, s2c, c2s, encryptType*);

   问题
   a) dh_group -> encryptType 这里dh_group原来有算法参数需要的选择含义，只能改成不能进行选择，1就是【初版】，2，3，4...就是以后新增encryptType了。
   b) SHandshake为了兼容，新增的encryptType必须放到最后面。旧版客户端会忽略，此时加密走的是【初版】。

3. SHandshake 
   dh_data -> encryptParam, binary保持不变。
   bool s2c -> int s2c，系列化兼容。
   bool c2s -> int c2s，系列化兼容。
   int encryptType，新增var。旧版客户端忽略并且看成初版加密类型来处理。

4. 压缩服务器强制要求的逻辑

路:
那样的话客户端可以发一个支持算法的列表，还是由服务器决定两边各用什么算法。

路:
客户端决定感觉不太妥当，服务器又不能完全信任客户端的选择

李成华:
压缩没有安全问题，可以让客户端选择把

李成华:
如果服务器真要完全决定，

李成华:
那就把客户端送上来的当作推荐，服务器根据自己的配置，决定是否采用。另外为了兼容（新增压缩），把最早的压缩算法看成客户端必须支持，就能选到能工作的压缩算法。

李成华:
服务器选择的逻辑：

李成华:
client send CHandshake( s2c建议, c2s 建议）建议包括不压缩。
server check 
realS2c = realByConfigS2c(argument.s2c);
realC2s = realByConfigC2s(argument.c2s)；// 这里处理所有逻辑。

李成华:
realByConfigS2c(client_s2c)
   if (s2cNeedCompress) {
         if (client_s2c != 0 && issupport) return client_s2c;
         return 1; // default.  
   }
   return client_s2c； // 服务器不强制时，直接采用客户端建议。
}
