
#### TODO

Zeze
	打包和更新工具
	async await?
	GlobalTaskOneByOneByKey？？？
	AsyncSocket.Connect Timeout 可配置，不是很有必要，外面需要同步等待时，可以设置自己的等待时间，不需要依赖Socket.Timeout。
	lua beankey 问题。

Zezex
	client: 可靠消息实现的错误检查。
	Bag里面的Money移走。

ConfigEditor
	自动完成: Foreign
	自动完成：id Load 的时候记录 maxid，以后编辑AddRow都使用这个递增。
	更多自动完成？普通的列默认最近使用的n个值，根据输入在列中查找最匹配的。
	增加一个工作线程，所有数据操作都放到这里面，和UI线程交互。看情况再决定做不做。
	enum 现在不支持引用在其他文档定义的，有需要了再来加。

GlobalCacheManagerWithRaft
	优化。改成一次AppendLog。
	关键：CacheState.AcquireStatePending 仅在Leader上使用，不需要同步到Follower。

DatabaseRocksDb
	OperatesRocksDb
	atomic flush
DatabaseTikv
	OperatesTikv

Raft.Agent
	重发现在在收到LeaderIs时马上重新发送。改成延迟？
	Agent的请求lost context，但是Task.Wait怎么返回的。

war？
	一个module集合。
	定义export？private？
	App.Instance？生成代码使用基类，不再使用具体类型，实际上就是把具体类型的功能尽量放到基类。
	感觉没必要：应用使用独立进程更加安全灵活些。

Connector.WaitReady
	GlobalAgent 重构？

Raft
	增加ConcurrentMapOnRocksDb
GlobalCacheManagerWithRaft
	改成ConcurrentMapOnRocksDb

RocksDb hot-copy 这样写？

// maindb
DB* maindb;
DB::Open(options, "/maindb", &db);

// bacup
BackupEngine* backup_engine;
BackupEngine::Open(Env::Default(), BackupableDBOptions("/backupdir"), &backup_engine);
backup_engine->CreateNewBackup(maindb);
delete backup_engine;
delete checkpointdb;

#include"rocksdb/db.h"
#include"rocksdb/utilities/backupable_db.h" 
#include<vector>
using namespace rocksdb;
int main()
{ 
	Options options; 
	options.create_if_missing = true; 
	DB* db; 
	Status s = DB::Open(options, "/tmp/rocksdb", &db); 
	assert(s.ok()); 
	db->Put(...); // do your thing 
	BackupEngine* backup_engine; 
	s = BackupEngine::Open(Env::Default(), BackupableDBOptions("/tmp/rocksdb_backup"), &backup_engine); 
	assert(s.ok()); 
	s = backup_engine->CreateNewBackup(db); 
	assert(s.ok()); 
	db->Put(...); // make some more changes 
	s = backup_engine->CreateNewBackup(db); 
	assert(s.ok()); 
	std::vector<BackupInfo> backup_info; 
	backup_engine->GetBackupInfo(&backup_info); // you can get IDs from backup_info if there are more than two 
	s = backup_engine->VerifyBackup(1); 
	assert(s.ok()); 
	s = backup_engine->VerifyBackup(2); 
	assert(s.ok()); 
	delete db; 
	delete backup_engine; 
}

#include"rocksdb/db.h" 
#include"rocksdb/utilities/backupable_db.h"
using namespace rocksdb;
int main() 
{ 
	BackupEngineReadOnly* backup_engine; 
	Status s = BackupEngineReadOnly::Open(Env::Default(), BackupableDBOptions("/tmp/rocksdb_backup"), &backup_engine); 
	assert(s.ok()); 
	s = backup_engine->RestoreDBFromBackup(1, "/tmp/rocksdb", "/tmp/rocksdb"); // RestoreDBFromLatestBackup
	assert(s.ok()); 
	delete backup_engine; 
}

ConcurrentMap 并发
	1. lock(value)
	2. duplicate key
Raft.ConcurrentMap 使用 RocksDb 持久化，自己实现快速 Snapshot，解决 RocksDb 没有这个功能的问题。

Socket async surpport
	用来给纯转发服务器用，可以避免使用多线程。

ReentrantReadWriteLock
	拥有 readLock 时，再次去锁 writeLock 会怎么样。

AsyncSocket c#
	优化，减少和逻辑层的互斥时间。
	？？？使用一个空的outputListSending去调用SendAsync???好像不可行。

对于全局模块的请求在优化前通过压力测试得到最大吞吐量。
考虑zeze增加协议最大吞吐量配置，达到60%时自动发送警告。
默认最大吞吐量为单个数据执行+1计算并且cache命中100%时的值。
当然这个值仅对全局共享的数据的访问有用，对于天然并发的事务是没有参考价值的。

确认zezex islocal loopback redirect 的实现

c# 发布 exe dll
    for unity ： 使用 framework.
    有一些 .net 5 才有的 api 需要处理。

性能测试表现，一秒一个事务，TableCache.Cleanup刚好一秒执行一次。改成了不忙等，至少Sleep一秒。需要确认效果。
########################### Global.Release并发问题 ###########################

# 问题

	0) 数据修改中途失败怎么办？
	   提前检查全部参数和逻辑条件，最后集中修改，然后祈祷修改不会失败。

	1) 调用其他模块的方法，里面也有数据修改怎么处理？
	   其他模块提供一个Precheck方法，提前检测。

	2) 如果其他模块又调用了其他模块？
	   是个坑。

	3) 线程安全问题？
	   真正，完全线程安全的，可以随意调用，并且随着功能增加仍然安全的代码是几乎不可能写的出来的。
	   一般都是使用各种简化策略，建立一个可控的访问模型来处理。

	4) 常用的多服务方案：根据功能划分不同的进程（服务），每个功能拥有自己的数据。
	   当某个服务的需求要关联其他服务（需要访问别的服务的数据）时，一般只能通过网络请求数据。
	   定义一堆访问协议，开发成本比较高。通过网络请求数据还有同步异步两种模式。
	   同步一般用于多线程，处理流程的代码写在一起，还比较清晰，但需要考虑多线程。
	   异步会把处理（回调模型好点）流程分割到多个代码块中，维护阅读比较麻烦。
	   纯粹的异步协议，接收是随机的，存在异步安全问题，需要很多上下文。
	   实际上纯粹的异步协议很容易出错，个人觉得比多线程还容易出错。

# 调查
	有多少人用过xdb。

# 目标

	0) 尽可能减少实现业务逻辑时需要的技术手段。降低应用开发难度。降低成本。
	   让实现代码离业务逻辑尽可能近，几乎能对照起来。
	1) 严格保护数据不损坏。
	2) 解决扩容问题，可以很容易构建成千上万台机器集群的服务。
	3) 解决高可用性问题，达到7x24小时不间断工作。

# 主要特性

	0) 事务
	   提供一般意义上的数据库的事务。
	   如果操作失败，会把放弃所有修改，把数据恢复到修改前的状态。
	   a) 异常安全
	      假设代码中任何地方都可能抛出异常，那么在没有事务支持的环境中
	      写出正确的代码是非常辛苦的。而现在的语言多数都是会抛出异常。
	   b) 更容易模块化
	      跨模块调用前可以先修改数据，调用后发现逻辑条件不符合，可以回滚。
	      更容易按需求定义模块接口，更容易实现代码尽量接近业务描述。

	1) 基于缓存同步的分布式事务
	   缓存同步跟 CPU 的 MESI（缓存一致性协议）类似。
	   这个功能由底层实现，应用除了配置不需要访问任何接口。
	   这是集群扩容的基础。编程的时候，就跟自己独占数据一样。
	   以后增加运行实例即可达到扩容目的。

	2) 简单网络库
	   真的非常简单，稍作封装后，对一般逻辑开发完全隐藏网络细节。
	   a) Protocol
	   b) Rpc

	3) 数据库封装
	   自动持久化到后端数据库。对应用来说，可以当作数据库不存在。
	   支持的数据库（以后根据需要添加，很容易）。
	   a) SQLServer
	   b) Mysql
	   c) Tikv

	4) Raft
	   用来支持高可靠性。

	5) 很容易就能访问所有数据
	   拥有所有数据，不会碰到到处要数据的问题。
	   实现逻辑很清晰。

	6) 乐观锁
	   不会死锁。重试会浪费cpu。但一般cpu是富裕的。

	7) 简单直接的编程接口，直接融入编程语言。
	   目前支持c#和java。

git 地址
https://gitee.com/e2wugui/zeze
https://github.com/e2wugui/zeze
