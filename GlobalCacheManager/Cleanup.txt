

一开始没有处理 LogicServer 连接断开时清理GlobalCacheManager的状态。
如果连接断开，简单看作 LogicServer 已经失效，让后续的Acquire请求可以成功。
LogicServer 发现发现连接断开，退出程序（非常野蛮）。

但即使是这样处理，仍然存在问题。即：连接断开导致 LogicServer 完全退出之间有时间窗口，
LogicServer 可能仍然继续处理了一些事务，它根据本地的State，使得修改成功了。
而GlobalCacheManager在连接断开时把它看成失效。

睡了一觉，都梦到了，但是仍然没有想到简单的方法。整理一下思路。

增加一条 NormalClose Rpc，在 LogicServer 正常关闭的时候发送给 GlobalCacheManager。
GlobalCacheManager 收到协议清理该 LogicServer 的所有记录状态。此外如果发现网络丢失，所有相关Acquire失败。

GlobalAgent 是 LogicServer 的连接管理类。

Shutdown 本地简单规则：
	关闭时，禁止新的存储过程，和丢弃没有在执行的任务。正在执行的，等待执行完成。
	see Zeze.Application.Stop, c# 线程池应该可以Shutdown吧。这些细节暂时先不管。

GlobalAgent:Close()
	Closed = true; // 之后所有 Acquire 请求都不再发送，也不重新建立连接，马上失败。
	NormalClose.SendAndWait();
	Socket.Close();

GlobalCacheManager.ProcessNormalClose()
	Release 所有该 LogicServer 分配的记录。需要在Session中维护分配的记录。

GlobalCacheManager.OnAcquire
	if (LogicServer.Reduce.NetNotExistOrError())
		return false; // 不再看作成功。XXX 看后面。

GlobalAgent::OnSocketClose_Passive()
	Closed = true; // 之后所有 Acquire 请求都不再发送，也不重新建立连接，马上失败。
	Cleanup local record in this GlobalCacheManager。遍历尝试实现。
	Checkpoint.RunOnce(); // 清理完成后保存一次。
	Closed = false; // 重新允许继续重连发送新请求。

这样处理的话，有没有”正确性“问题呢。还有没有时间窗口。
如果没有时间问题了。再处理最后一个问题：如果 LogicServer 一直没起来，
那么所有原来分配到它的记录都无法被别人申请。
这个问题暂时想到的方法是超时，比如5分钟。过后，NetNotExist看作成功。
这里超时的意义是让GlobalAgent::OnSocketClose_Passive()能完成工作。
如果 LogicServer 已经异常退出，那么它的本地状态当然都是失效的。

当然，重连的话，GlobalCacheManager 还需要识别和处理。方法是连接建立成功发送
LogicServer.ServerId。现在框架里面存在的Id就是AutoKeyLocalId。
