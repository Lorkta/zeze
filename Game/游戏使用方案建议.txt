
游戏怎么使用zeze建议。

1. 建议采用cache同步技术，使得游戏逻辑服务器无状态化（登录任何逻辑服务器实例都可以），
	注意：
	cache同步只能同步持久化的数据。
	如果使用内存表等本地进程相关的数据的相关功能还是跟服务器相关。比如组队，地图相关数据。
	可行的解决办法是全部使用持久化，不要使用仅本进程可见的数据。
	这点需要仔细考虑。

2.建议采用虚拟服务器。
	游戏分服的最初的主要原因是性能，后来变成运营需求（让玩家创建新角色，重新玩）。
	但是后来很多游戏又都要求能跨服玩，现在很多游戏都是这样的。
	所以如果没有性能问题，分服可以假的服务器，除了部分分服相关的功能需要考虑，实际上都在一个服务器里面运行。
	分服相关功能的例子如下：
	1 角色列表分服保存，在账号表（User Or Account）中定义 map<serverid, rolelist>就可以了。
	2 角色信息（RoleInfo）包含serverid属性。
	3 分服相关排行榜。
	4 社交系统（公会什么）可能需要分服建立，虽然没有必要。
	5 地图服务器的实例分配规则默认根据serverid。本质上地图服务器是允许不同服的玩家一起玩的。

	除了以上功能其他功能都是不考虑服务器的。
	这样的话，创建服务器和合并服务器都很简单：
	1 创建新的服务器，就是在服务器列表中加一项，分配一个serverid就可以了。
	2 合服就是把账号表的列表修改一下，把RoleInfo.serverid更新一下。
	  把社交系统（需要的话）更新一下。

3. 建议客户端采用TypeScript。

4. 是否建立独立的地图服务器。实现开放地图的游戏，涉及到地图中玩家信息同步。
	a) 如果地图服务器不装载3d场景信息，只是做简单的2d范围通告，那么没必要建立独立进程。
	   把相关功能合并到逻辑服务器内即可。
	b) 如果使用了unreal-server或者unity3d后台模式来当作地图服务器的话，那就和3d引擎相关。
	   这种应该可以实现碰撞等验证，没有性能问题的话，也算是个解决方案。
	   采用这种方案的地图服务器，和Zeze配合的话，需要把地图相关功能和普通逻辑功能做一个好的划分。
	c) 另外服务器如果不直接支持碰撞和nav-mesh寻路，可以仅仅把客户端的结果拿去验证。
	   有个思路，1 抽样验证；2 验证的时候随机选择几个客户端来执行验证，防止单个客户端作弊。
	   服务器有寻路需求的时候也可以选择客户端帮忙做。

客户端使用Unity(csharp)+TypeScript
	a) 把 Zeze 加到你的项目。
	b) 定义宏 USE_PUERTS
	c) 把 TypeScript/ts/ 下的 zeze.ts long.js 拷贝到你的 ts 目录。
	   long.js 来自于 https://github.com/dcodeIO/Long.js/ 好像 nodejs 也有一个 Long 实现，还没看，不知道接口是否一致。
	d) 把 typeof(Zeze.Services.ToTypeScriptService) 加到 puerts 的 Bindings 列表中。
	e) 定义 solutions.xml 时，客户端要处理的协议的 handle 设置为 clientscript.

客户端使用Unreal(cxx)+TypeScript
	a) 直接把cxx下的所有代码加到项目中。除了ToLua相关的。
	b) 把 TypeScript/ts/ 下的 zeze.ts long.js 拷贝到你的 ts 目录。
	   long.js 来自于 https://github.com/dcodeIO/Long.js/ 好像 nodejs 也有一个 Long 实现，还没看，不知道接口是否一致。
	c) cxx 怎么绑定？TODO
	d) 定义 solutions.xml 时，客户端要处理的协议的 handle 设置为 clientscript.

客户端使用Unity(csharp)+lua
	a) 需要选择你的Lua-Bind的类库，实现一个ILua实现（参考 Zeze.Service.ToLuaService.cs）。
	b) 定义 solutions.xml 时，客户端要处理的协议的 handle 设置为 clientscript.

客户端使用Unreal(cxx)+lua
	a) 依赖lualib, 需要设置includepath
	b) 直接把cxx下的所有代码加到项目中。除了ToTypeScript相关的。
	c) 定义 solutions.xml 时，客户端要处理的协议的 handle 设置为 clientscript.
